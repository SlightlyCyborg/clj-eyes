(ns clj-eyes.pipeline-test
  (:use clojure.test)
  (:require [clj-eyes.cv-pipeline :as pipeline]))

(import '[org.opencv.core MatOfInt MatOfByte Mat CvType Size]
        '[org.opencv.imgcodecs Imgcodecs]
        '[org.opencv.imgproc Imgproc])

(deftest load-new-source
 (let [test-atom (atom {})] 
  (is (=
       (type (:data (get @(pipeline/load-new-source "resources/imgs/tomato_plants.jpg" 1 test-atom) 1)))
       org.opencv.core.Mat))))

(deftest load-new-source
  ;load new sorce requires an atom representing the pipeline
  (let [pipeline-list 
        (pipeline/load-new-source "resources/imgs/tomato_plants.jpg" 1 {})]
     (is
      (contains? (get pipeline-list 1 nil) :pipeline-source-img))
     ;;Then assert that the frame contains what a frame should contain an id and a sourc frame
     (let [src-frame (:pipeline-source-img (get pipeline-list 1 nil))]
       (is (contains? src-frame :id))
       (is (contains? src-frame :source-frame)))))

(deftest fetch-webp
  (let [webp-struct (pipeline/fetch-webp (pipeline/load-new-source "resources/imgs/tomato_plants.jpg" 1 {}) 1 :pipeline-source-img)]
    (is (= (type (:value webp-struct)) org.opencv.core.MatOfByte))))


(run-tests)

(clojure.test/test-vars [#'clj-eyes.pipeline-test/fetch-webp])
